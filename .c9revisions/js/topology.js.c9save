{"ts":1376665110368,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var type = require(\"./type\"),\r\n    stitch = require(\"./stitch-poles\"),\r\n    hashtable = require(\"./hashtable\"),\r\n    systems = require(\"./coordinate-systems\");\r\n\r\nvar e = 1e-6;\r\n\r\nmodule.exports = function(objects, options) {\r\n  var Q = 1e4; // precision of quantization\r\n  var id = function(d) { return d.id; }; // function to compute object id\r\n  var propertyTransform = function() {}; // function to transform properties\r\n  var stitchPoles = true;\r\n  var verbose = false;\r\n  var x0, y0, x1, y1;\r\n  var kx, ky;\r\n  var emax = 0;\r\n  var coincidences;\r\n  var system = null;\r\n  var arcs = [];\r\n  var arcsByPoint;\r\n  var pointsByPoint;\r\n\r\n  if (options) {\r\n    if (\"verbose\" in options) {\r\n      verbose = !!options.verbose;\r\n    }\r\n    if (\"stitch-poles\" in options) {\r\n      stitchPoles = !!options[\"stitch-poles\"];\r\n    }\r\n    if (\"coordinate-system\" in options) {\r\n      system = systems[options[\"coordinate-system\"]];\r\n    }\r\n    if (\"quantization\" in options) {\r\n      Q = +options.quantization;\r\n    }\r\n    if (\"id\" in options) {\r\n      id = options.id;\r\n    }\r\n    if (\"property-transform\") {\r\n      propertyTransform = options[\"property-transform\"];\r\n    }\r\n  }\r\n\r\n  coincidences = hashtable(Q * 10);\r\n  arcsByPoint = hashtable(Q * 10);\r\n  pointsByPoint = hashtable(Q * 10);\r\n\r\n  function each(callback) {\r\n    var t = type(callback);\r\n    var o = {};\r\n    for (var k in objects) {\r\n      o[k] = t.object(objects[k]) || {};\r\n    }\r\n    return o;\r\n  }\r\n\r\n  // Compute bounding box.\r\n  function bound() {\r\n    x1 = y1 = -(x0 = y0 = Infinity);\r\n    each({\r\n      point: function(point) {\r\n        var x = point[0];\r\n        var y = point[1];\r\n        if (x < x0) {\r\n          x0 = x;\r\n        }\r\n        if (x > x1) {\r\n          x1 = x;\r\n        }\r\n        if (y < y0) {\r\n          y0 = y;\r\n        }\r\n        if (y > y1) {\r\n          y1 = y;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  bound();\r\n\r\n  // For automatic coordinate system determination, consider the bounding box.\r\n  var oversize = x0 < -180 - e || x1 > 180 + e || y0 < -90 - e || y1 > 90 + e;\r\n  if (!system) {\r\n    system = systems[oversize ? \"cartesian\" : \"spherical\"];\r\n    if (options) {\r\n      options[\"coordinate-system\"] = system.name;\r\n    }\r\n  }\r\n\r\n  if (system === systems.spherical) {\r\n    if (oversize) {\r\n      throw new Error(\"spherical coordinates outside of [±180°, ±90°]\");\r\n    }\r\n    if (stitchPoles) {\r\n      stitch(objects);\r\n      bound();\r\n    }\r\n\r\n    // When near the spherical coordinate limits, clamp to nice round values.\r\n    // This avoids quantized coordinates that are slightly outside the limits.\r\n    if (x0 < -180 + e) {\r\n      x0 = -180;\r\n    }\r\n    if (x1 > 180 - e) {\r\n      x1 = 180;\r\n    }\r\n    if (y0 < -90 + e) {\r\n      y0 = -90;\r\n    }\r\n    if (y1 > 90 - e) {\r\n      y1 = 90;\r\n    }\r\n  }\r\n\r\n  if (!isFinite(x0)) {\r\n    x0 = 0;\r\n  }\r\n  if (!isFinite(x1)) {\r\n    x1 = 0;\r\n  }\r\n  if (!isFinite(y0)) {\r\n    y0 = 0;\r\n  }\r\n  if (!isFinite(y1)) {\r\n    y1 = 0;\r\n  }\r\n  // Compute quantization scaling factors.\r\n  if (Q) {\r\n    kx = x1 - x0 ? (Q - 1) / (x1 - x0) : 1;\r\n    ky = y1 - y0 ? (Q - 1) / (y1 - y0) : 1;\r\n  } else {\r\n    console.warn(\"quantization: disabled; assuming inputs already quantized\");\r\n    Q = x1 + 1;\r\n    kx = ky = 1;\r\n    x0 = y0 = 0;\r\n  }\r\n\r\n  if (verbose) {\r\n    var qx0 = Math.round((x0 - x0) * kx) * (1 / kx) + x0;\r\n    var qx1 = Math.round((x1 - x0) * kx) * (1 / kx) + x0;\r\n    var qy0 = Math.round((y0 - y0) * ky) * (1 / ky) + y0;\r\n    var qy1 = Math.round((y1 - y0) * ky) * (1 / ky) + y0;\r\n    console.warn(\"quantization: bounds \" + [qx0, qy0, qx1, qy1].join(\" \") + \" (\" + system.name + \")\");\r\n  }\r\n\r\n  // Quantize coordinates.\r\n  each({\r\n    point: function(point) {\r\n      var x1 = point[0];\r\n      var y1 = point[1];\r\n      var x = Math.round((x1 - x0) * kx);\r\n      var y = Math.round((y1 - y0) * ky);\r\n      var e = system.distance(x1, y1, x / kx + x0, y / ky + y0);\r\n      if (e > emax) {\r\n        emax = e;\r\n      }\r\n      point[0] = x;\r\n      point[1] = y;\r\n    }\r\n  });\r\n\r\n  if (verbose) {\r\n    console.warn(\"quantization: maximum error \"  + system.formatDistance(emax));\r\n  }\r\n\r\n  // Compute the line strings that go through each unique point.\r\n  // If the line string goes through the same point more than once,\r\n  // only record that point once.\r\n  each({\r\n    line: function(line) {\r\n      var i = -1;\r\n      var n = line.length;\r\n      var lines;\r\n      while (++i < n) {\r\n        lines = coincidences.get(line[i]);\r\n        if (lines.indexOf(line) < 0) {\r\n          lines.push(line);\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  // Convert features to geometries, and stitch together arcs.\r\n  objects = each({\r\n    Feature: function(feature) {\r\n      var geometry = feature.geometry;\r\n      if (feature.geometry == null) {\r\n        geometry = {};\r\n      }\r\n      if (\"id\" in feature) {\r\n        geometry.id = feature.id;\r\n      }\r\n      if (\"properties\" in feature) {\r\n        geometry.properties = feature.properties;\r\n      }\r\n      return this.geometry(geometry);\r\n    },\r\n\r\n    FeatureCollection: function(collection) {\r\n      collection.type = \"GeometryCollection\";\r\n      collection.geometries = collection.features.map(this.Feature, this);\r\n      delete collection.features;\r\n      return collection;\r\n    },\r\n\r\n    GeometryCollection: function(collection) {\r\n      collection.geometries = collection.geometries.map(this.geometry, this);\r\n    },\r\n\r\n    MultiPolygon: function(multiPolygon) {\r\n      multiPolygon.arcs = multiPolygon.coordinates.map(polygon);\r\n    },\r\n\r\n    Polygon: function(polygon) {\r\n      polygon.arcs = polygon.coordinates.map(lineClosed);\r\n    },\r\n\r\n    MultiLineString: function(multiLineString) {\r\n      multiLineString.arcs = multiLineString.coordinates.map(lineOpen);\r\n    },\r\n\r\n    LineString: function(lineString) {\r\n      lineString.arcs = lineOpen(lineString.coordinates);\r\n    },\r\n\r\n    geometry: function(geometry) {\r\n      if (geometry == null) {\r\n        geometry = {};\r\n      } else {\r\n        this.defaults.geometry.call(this, geometry);\r\n      }\r\n\r\n      geometry.id = id(geometry);\r\n      if (geometry.id == null) {\r\n        delete geometry.id;\r\n      }\r\n      var properties0 = geometry.properties;\r\n      if (properties0) {\r\n        var properties1 = {};\r\n        delete geometry.properties;\r\n        for (var key0 in properties0) {\r\n          if (propertyTransform(properties1, key0, properties0[key0])) {\r\n            geometry.properties = properties1;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (geometry.arcs) {\r\n        delete geometry.coordinates;\r\n      }\r\n      return geometry;\r\n    }\r\n  });\r\n\r\n  coincidences = arcsByPoint = pointsByPoint = null;\r\n\r\n  function polygon(poly) {\r\n    return poly.map(lineClosed);\r\n  }\r\n\r\n  function lineClosed(points) {\r\n    return line(points, false);\r\n  }\r\n\r\n  function lineOpen(points) {\r\n    return line(points, true);\r\n  }\r\n\r\n  function line(points, open) {\r\n    var lineArcs = [];\r\n    var n = points.length;\r\n    var a = [];\r\n    var k = 0;\r\n    var p;\r\n    var point;\r\n    var t;\r\n    var tInP;\r\n    var pInT;\r\n    var i;\r\n\r\n    if (!open) {\r\n      points.pop();\r\n      --n;\r\n    }\r\n\r\n    // For closed lines, rotate to find a suitable shared starting point.\r\n    for (; k < n; ++k) {\r\n      t = coincidences.peek(points[k]);\r\n      if (open) {\r\n        break;\r\n      }\r\n      if (p && !linesEqual(p, t)) {\r\n        tInP = t.every(function(line) { return p.indexOf(line) >= 0; });\r\n        pInT = p.every(function(line) { return t.indexOf(line) >= 0; });\r\n        if (tInP && !pInT) {\r\n          --k;\r\n        }\r\n        break;\r\n      }\r\n      p = t;\r\n    }\r\n    // If no shared starting point is found for closed lines, rotate to minimum.\r\n    if (k === n && p.length > 1) {\r\n      var point0 = points[0];\r\n      i = 0;\r\n      for (k = 0; i < n; ++i) {\r\n        point = points[i];\r\n        if (pointCompare(point0, point) > 0) {\r\n          point0 = point;\r\n          k = i;\r\n        }\r\n      }\r\n    }\r\n    i = 0;\r\n    for (var m = open ? n : n + 1; i < m; ++i) {\r\n      point = points[(i + k) % n];\r\n      p = coincidences.peek(point);\r\n      if (!linesEqual(p, t)) {\r\n        tInP = t.every(function(line) { return p.indexOf(line) >= 0; });\r\n        pInT = p.every(function(line) { return t.indexOf(line) >= 0; });\r\n        if (tInP) {\r\n          a.push(point);\r\n        }\r\n        arc(a);\r\n        if (!tInP && !pInT) {\r\n          arc([a[a.length - 1], point]);\r\n        }\r\n        if (pInT) {\r\n          a = [a[a.length - 1]];\r\n        } else {\r\n          a = [];\r\n        }\r\n      }\r\n      if (!a.length || pointCompare(a[a.length - 1], point)) {\r\n        a.push(point); // skip duplicate points\r\n      }\r\n      t = p;\r\n    }\r\n\r\n    arc(a, true);\r\n\r\n    function arc(a, last) {\r\n      var n = a.length;\r\n      var point;\r\n      if (last && !lineArcs.length && n === 1) {\r\n        point = a[0];\r\n        var index = pointsByPoint.get(point);\r\n        if (index.length) {\r\n          lineArcs.push(index[0]);\r\n        } else {\r\n          lineArcs.push(index[0] = arcs.length);\r\n          arcs.push(a);\r\n        }\r\n      } else if (n > 1) {\r\n        var a0 = a[0];\r\n        var a1 = a[n - 1];\r\n        point = pointCompare(a0, a1) < 0 ? a0 : a1;\r\n        var pointArcs = arcsByPoint.get(point);\r\n        if (pointArcs.some(matchForward)) {\r\n          return;\r\n        }\r\n        if (pointArcs.some(matchBackward)) {\r\n          return;\r\n        }\r\n        pointArcs.push(a);\r\n        lineArcs.push(a.index = arcs.length);\r\n        arcs.push(a);\r\n      }\r\n\r\n      function matchForward(b) {\r\n        var i = -1;\r\n        if (b.length !== n) {\r\n          return false;\r\n        }\r\n        while (++i < n) {\r\n          if (pointCompare(a[i], b[i])) {\r\n            return false;\r\n          }\r\n        }\r\n        lineArcs.push(b.index);\r\n        return true;\r\n      }\r\n\r\n      function matchBackward(b) {\r\n        var i = -1;\r\n        if (b.length !== n) {\r\n          return false;\r\n        }\r\n        while (++i < n) {\r\n          if (pointCompare(a[i], b[n - i - 1])) {\r\n            return false;\r\n          }\r\n        }\r\n        lineArcs.push(~b.index);\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return lineArcs;\r\n  }\r\n\r\n  return {\r\n    type: \"Topology\",\r\n    bbox: [x0, y0, x1, y1],\r\n    transform: {\r\n      scale: [1 / kx, 1 / ky],\r\n      translate: [x0, y0]\r\n    },\r\n    objects: objects,\r\n    arcs: arcs.map(function(arc) {\r\n      var i = 0;\r\n      var n = arc.length;\r\n      var point = arc[0];\r\n      var x1 = point[0];\r\n      var x2;\r\n      var dx;\r\n      var y1 = point[1];\r\n      var y2;\r\n      var dy;\r\n      var points = [[x1, y1]];\r\n      while (++i < n) {\r\n        point = arc[i];\r\n        x2 = point[0];\r\n        y2 = point[1];\r\n        dx = x2 - x1;\r\n        dy = y2 - y1;\r\n        if (dx || dy) {\r\n          points.push([dx, dy]);\r\n          x1 = x2;\r\n          y1 = y2;\r\n        }\r\n      }\r\n      return points;\r\n    })\r\n  };\r\n};\r\n\r\nfunction linesEqual(a, b) {\r\n  var n = a.length;\r\n  var i = -1;\r\n  if (b.length !== n) {\r\n    return false;\r\n  }\r\n  while (++i < n) {\r\n    if (a[i] !== b[i]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction pointCompare(a, b) {\r\n  return a[0] - b[0] || a[1] - b[1];\r\n}\r\n\r\n"]],"start1":0,"start2":0,"length1":0,"length2":11173}]],"length":11173}
