{"ts":1376680776673,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var pi = Math.PI;\r\nvar pi4 = pi / 4;\r\nvar radians = pi / 180;\r\n\r\nexports.name = \"spherical\";\r\nexports.formatDistance = formatDistance;\r\nexports.ringArea = ringArea;\r\nexports.absoluteArea = absoluteArea;\r\nexports.triangleArea = triangleArea;\r\nexports.distance = haversinDistance; // XXX why two implementations?\r\n\r\nfunction formatDistance(radians) {\r\n  var km = radians * 6371;\r\n  return (km > 1 ? km.toFixed(3) + \"km\" : (km * 1000).toPrecision(3) + \"m\") +\r\n    \" (\" + (radians * 180 / Math.PI).toPrecision(3) + \"°)\";\r\n}\r\n\r\nfunction ringArea(ring) {\r\n  if (!ring.length) {\r\n    return 0;\r\n  }\r\n  var area = 0;\r\n  var p = ring[0];\r\n  var lambda = p[0] * radians;\r\n  var phi = p[1] * radians / 2 + pi4;\r\n  var lambda0 = lambda;\r\n  var cosphi0 = Math.cos(phi);\r\n  var sinphi0 = Math.sin(phi);\r\n\r\n  for (var i = 1, n = ring.length; i < n; ++i) {\r\n    p = ring[i];\r\n    lambda = p[0] * radians;\r\n    phi = p[1] * radians / 2 + pi4;\r\n\r\n    // Spherical excess E for a spherical triangle with vertices: south pole,\r\n    // previous point, current point.  Uses a formula derived from Cagnoli’s\r\n    // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\r\n    var dlambda = lambda - lambda0;\r\n    var cosphi = Math.cos(phi);\r\n    var sinphi = Math.sin(phi);\r\n    var k = sinphi0 * sinphi;\r\n    var u = cosphi0 * cosphi + k * Math.cos(dlambda);\r\n    var v = k * Math.sin(dlambda);\r\n    area += Math.atan2(v, u);\r\n\r\n    // Advance the previous point.\r\n    lambda0 = lambda;\r\n    cosphi0 = cosphi;\r\n    sinphi0 = sinphi;\r\n  }\r\n\r\n  return 2 * area;\r\n}\r\n\r\nfunction absoluteArea(a) {\r\n  return a < 0 ? a + 4 * pi : a;\r\n}\r\n\r\nfunction triangleArea(t) {\r\n  var a = distance(t[0], t[1]);\r\n  var b = distance(t[1], t[2]);\r\n  var c = distance(t[2], t[0]);\r\n  var s = (a + b + c) / 2;\r\n  return 4 * Math.atan(Math.sqrt(Math.max(0, Math.tan(s / 2) * Math.tan((s - a) / 2) * Math.tan((s - b) / 2) * Math.tan((s - c) / 2))));\r\n}\r\n\r\nfunction distance(a, b) {\r\n  var deltalambda = (b[0] - a[0]) * radians;\r\n  var sindeltalambda = Math.sin(deltalambda);\r\n  var cosdeltalambda = Math.cos(deltalambda);\r\n  var sinphi0 = Math.sin(a[1] * radians);\r\n  var cosphi0 = Math.cos(a[1] * radians);\r\n  var sinphi1 = Math.sin(b[1] * radians);\r\n  var cosphi1 = Math.cos(b[1] * radians);\r\n  var _;\r\n  return Math.atan2(Math.sqrt((_ = cosphi1 * sindeltalambda) * _ + (_ = cosphi0 * sinphi1 - sinphi0 * cosphi1 * cosdeltalambda) * _), sinphi0 * sinphi1 + cosphi0 * cosphi1 * cosdeltalambda);\r\n}\r\n\r\nfunction haversinDistance(x0, y0, x1, y1) {\r\n  x0 *= radians;\r\n  y0 *= radians;\r\n  x1 *= radians;\r\n  y1 *= radians;\r\n  return 2 * Math.asin(Math.sqrt(haversin(y1 - y0) + Math.cos(y0) * Math.cos(y1) * haversin(x1 - x0)));\r\n}\r\n\r\nfunction haversin(x) {\r\n  return (x = Math.sin(x / 2)) * x;\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":2759}]],"length":2759}
